{
  parserClass="com.feakin.intellij.parser.FeakinParser"
  parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"
  psiImplUtilClass="com.feakin.intellij.parser.FeakinPsiImplUtil"

  implements="com.feakin.intellij.psi.FeakinPsiCompositeElement"
  extends="com.feakin.intellij.psi.impl.FeakinPsiCompositeElementImpl"

  psiClassPrefix="Feakin"
  psiImplClassSuffix="Impl"
  psiPackage="com.feakin.intellij.psi"
  psiImplPackage="com.feakin.intellij.psi.impl"

  elementTypeHolderClass="com.feakin.intellij.lexer.FeakinElementTypes"
  elementTypeClass="com.feakin.intellij.psi.impl.FeakinElementType"

  tokenTypeClass="com.feakin.intellij.lexer.FeakinTokenType"

  tokenTypeClass="com.feakin.intellij.lexer.FeakinTokenType"
  tokens = [
      COMMENT               = 'regexp://[^\r\n]*'
      BLOCK_COMMENT         = 'regexp:[/][*][^*]*[*]+([^/*][^*]*[*]+)*[/]'

      IDENTIFIER            = 'regexp:[_a-zA-Z][_a-zA-Z0-9]*'
      STRING_LITERAL        = "regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"

      COMMA                 = ','
      COLON                 = ":"
      DOUBLE_COLON          = "::"
      SEMICOLON             = ";"
      LBRACE                = "{"
      RBRACE                = "}"
      EQUAL                 = "="
      QUOTA                 = "'"
      LPAREN                = '('
      RPAREN                = ')'
      LT                    =  '<'
      GT                    =  '>'
      DOT                   =  '.'
      RARROW                = "->"
      LARROW                = "<-"
      DARROW                = "<->"
      CONNECTION            = "--"

      CONTEXT_MAP_KEYWORD   = 'ContextMap'
      CONTEXT_KEYWORD       = 'Context'
      AGGREGATE_KEYWORD     = 'Aggregate'
      ENTITY_KEYWORD        = 'Entity'
      VALUE_OBJECT_KEYWORD  = 'ValueObject'
      STRUCT_KEYWORD        = 'Struct'
      IMPL_KEYWORD          = 'impl'
      ENDPOINT_KEYWORD      = 'endpoint'
      REQUEST_KEYWORD       = 'request'
      RESPONSE_KEYWORD      = 'response'

      GET_KEYWORD           = 'GET'
      POST_KEYWORD          = 'POST'
      PUT_KEYWORD           = 'PUT'
      DELETE_KEYWORD        = 'DELETE'
      PATCH_KEYWORD         = 'PATCH'
      HEAD_KEYWORD          = 'HEAD'
      OPTIONS_KEYWORD       = 'OPTIONS'
      AUTH_KEYWORD          = 'authorization'

      FLOW_KEYWORD          = 'flow'
      VIA_KEYWORD           = 'via'
      RECEIVE_KEYWORD       = 'receive'
      SEND_KEYWORD          = 'send'
      TO_KEYWORD            = 'to'
      FROM_KEYWORD          = 'from'
  ]
}

compilationUnit ::= declaration*

declaration ::= contextMapDeclaration
               | contextDeclaration
               | aggregateDeclaration
               | entityDeclaration
               | valueObjectDeclaration
               | structDeclaration
               | implDeclaration

contextMapDeclaration ::= CONTEXT_MAP_KEYWORD contextMapName LBRACE contextMapBody? RBRACE
{
  mixin="com.feakin.intellij.psi.impl.FeakinNamedElementImpl"
  implements="com.feakin.intellij.psi.FeakinNamedElement"
  methods=[getName getPresentation]
}

contextMapBody ::= (contextNodeDecl | contextNodeRel)*

private contextNodeDecl ::= CONTEXT_KEYWORD contextName  (COMMA contextName)*

private contextNodeRel ::= leftContextNode relSymbol rightContextNode SEMICOLON
{
  implements="com.feakin.intellij.psi.FeakinContextNodeRel"
  methods=[getLeftNode getRightNode]
}

private leftContextNode ::= contextNodeName;

private rightContextNode ::= contextNodeName;

relSymbol ::= RARROW
             | LARROW
             | DARROW
             | CONNECTION
             ;

contextDeclaration ::= CONTEXT_KEYWORD contextName LBRACE contextBody RBRACE
{
  mixin="com.feakin.intellij.psi.impl.FeakinNamedElementImpl"
  implements="com.feakin.intellij.psi.FeakinNamedElement"
  methods=[getName getPresentation]
}

aggregateDeclaration ::= AGGREGATE_KEYWORD aggregateName LBRACE aggregateBody RBRACE

entityDeclaration ::= ENTITY_KEYWORD entityName LBRACE entityBody? RBRACE

valueObjectDeclaration ::= VALUE_OBJECT_KEYWORD valueObjectName LBRACE valueObjectBody? RBRACE

contextBody ::= useAggregate*

private useAggregate ::= AGGREGATE_KEYWORD name_component (COMMA name_component)* SEMICOLON

aggregateBody ::= aggregateEntry*

private aggregateEntry ::= useEntity

private useEntity ::= ENTITY_KEYWORD name_component (COMMA name_component)* SEMICOLON

entityBody ::= structDeclaration
              | useValueObject
              | useStruct

structDeclaration ::= STRUCT_KEYWORD LBRACE structBody RBRACE

structBody ::= structEntry*

private structEntry ::= IDENTIFIER COLON fieldType defaultValue? SEMICOLON?

fieldType ::= IDENTIFIER ('<' IDENTIFIER '>')?
              ;

private defaultValue ::= EQUAL IDENTIFIER ('.' IDENTIFIER )?

private useValueObject ::= VALUE_OBJECT_KEYWORD name_component (COMMA name_component)? SEMICOLON
private useStruct      ::= STRUCT_KEYWORD name_component (COMMA name_component)? SEMICOLON

valueObjectBody ::= structDeclaration
                  | useStruct

implDeclaration ::= IMPL_KEYWORD implName LBRACE implBody? RBRACE

implBody ::= endpointDeclaration flowDeclaration?

endpointDeclaration ::= ENDPOINT_KEYWORD LBRACE endpointBody RBRACE

endpointBody ::=  requestDeclaration requestBody? authorizationDecl? responseDeclaration?

private authorizationDecl ::= AUTH_KEYWORD COLON authorizationType? authorizationValue* SEMICOLON?

authorizationValue ::= IDENTIFIER
authorizationType ::= IDENTIFIER

requestDeclaration ::= httpRequestDeclaration

private httpRequestDeclaration ::= httpMethod uri SEMICOLON

httpMethod ::= GET_KEYWORD
              | POST_KEYWORD
              | PUT_KEYWORD
              | DELETE_KEYWORD
              | PATCH_KEYWORD
              | HEAD_KEYWORD
              | OPTIONS_KEYWORD
              ;

uri ::= STRING_LITERAL

requestBody ::= REQUEST_KEYWORD COLON (requestEntityName | structDeclaration) SEMICOLON;

responseDeclaration ::= RESPONSE_KEYWORD COLON responseEntityName SEMICOLON;

flowDeclaration ::= FLOW_KEYWORD LBRACE flowBody RBRACE

flowBody ::= flowEntry*
private flowEntry ::= viaMethodDeclaration
                     | viaMessageDeclaration

viaMethodDeclaration ::= VIA_KEYWORD objectName (DOUBLE_COLON viaMethodName parameters?)? RECEIVE_KEYWORD receiveObject SEMICOLON?

parameters ::= LPAREN parameter (COMMA parameter)* RPAREN

parameter ::= IDENTIFIER COLON paramType

paramType ::= IDENTIFIER ('<' IDENTIFIER '>')?
              ;

private receiveObject ::= objectName (COLON viaMethodName)?

viaMessageDeclaration ::= VIA_KEYWORD objectName SEND_KEYWORD passObject TO_KEYWORD topic SEMICOLON?

private passObject ::= objectName (COLON viaMethodName)?

topic ::= STRING_LITERAL

objectName ::= name_component

viaMethodName ::= name_component

requestEntityName ::= name_component

responseEntityName ::= name_component

contextMapName ::= name_component

contextName ::= name_component

aggregateName ::= name_component

entityName ::= name_component

valueObjectName ::= name_component

contextNodeName ::= name_component

implName ::= name_component

name_component ::= IDENTIFIER
{
  mixin="com.feakin.intellij.psi.impl.FeakinNamedElementImpl"
  implements="com.feakin.intellij.psi.FeakinNamedElement"

  methods=[
    getReference
  ]
}
