{
  parserClass="com.feakin.intellij.parser.FkParser"
  parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

  implements="com.feakin.intellij.psi.FkElement"
  extends="com.feakin.intellij.psi.impl.FkElementImpl"

  psiClassPrefix="Fk"
  psiImplClassSuffix="Impl"
  psiPackage="com.feakin.intellij.psi"
  psiImplPackage="com.feakin.intellij.psi.impl"

  elementTypeHolderClass="com.feakin.intellij.lexer.FkElementTypes"
  elementTypeClass="com.feakin.intellij.psi.FkElementType"

  tokenTypeClass="com.feakin.intellij.lexer.FkTokenType"

  tokenTypeClass="com.feakin.intellij.lexer.FkTokenType"
  tokens = [
      COMMENT               = 'regexp://[^\r\n]*'
      BLOCK_COMMENT         = 'regexp:[/][*][^*]*[*]+([^/*][^*]*[*]+)*[/]'

      IDENTIFIER            = 'regexp:[_a-zA-Z][_a-zA-Z0-9]*'
      STRING_LITERAL        = "regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"

      COMMA                 = ','
      COLON                 = ":"
      DOUBLE_COLON          = "::"
      SEMICOLON             = ";"
      LBRACE                = "{"
      RBRACE                = "}"
      EQUAL                 = "="
      QUOTA                 = "'"
      LPAREN                = '('
      RPAREN                = ')'
      LT                    =  '<'
      GT                    =  '>'
      DOT                   =  '.'
      RARROW                = "->"
      LARROW                = "<-"
      DARROW                = "<->"
      CONNECTION            = "--"

      CONTEXT_MAP_KEYWORD   = 'ContextMap'
      CONTEXT_KEYWORD       = 'Context'
      AGGREGATE_KEYWORD     = 'Aggregate'
      ENTITY_KEYWORD        = 'Entity'
      VALUE_OBJECT_KEYWORD  = 'ValueObject'
      STRUCT_KEYWORD        = 'Struct'
      IMPL_KEYWORD          = 'impl'
      ENDPOINT_KEYWORD      = 'endpoint'
      REQUEST_KEYWORD       = 'request'
      RESPONSE_KEYWORD      = 'response'
      AGGREGATE_S_KEYWORD   = 'aggregate'
      ENTITY_S_KEYWORD      = 'entity'

      GET_KEYWORD           = 'GET'
      POST_KEYWORD          = 'POST'
      PUT_KEYWORD           = 'PUT'
      DELETE_KEYWORD        = 'DELETE'
      PATCH_KEYWORD         = 'PATCH'
      HEAD_KEYWORD          = 'HEAD'
      OPTIONS_KEYWORD       = 'OPTIONS'
      AUTH_KEYWORD          = 'authorization'

      FLOW_KEYWORD          = 'flow'
      VIA_KEYWORD           = 'via'
      RECEIVE_KEYWORD       = 'receive'
      SEND_KEYWORD          = 'send'
      TO_KEYWORD            = 'to'
      FROM_KEYWORD          = 'from'
      LAYERED_KEYWORD       = 'layered'
      LAYER_KEYWORD         = 'layer'
      DEPENDENCY_KEYWORD    = 'dependency'
      PACKAGE_KEYWORD       = 'package'
      DOMAIN_EVENT_KEYWORD  = 'DomainEvent'

      SOURCE_SET_KEYWORD    = 'SourceSet'

      // expression
      WHEN_KEYWORD          = 'when'
      IS_KEYWORD            = 'is'

      VAR_KEYWORD           = 'var'
      DEF_KEYWORD           = 'def'
      INCLUDE_KEYWORD       = 'include'
  ]
}

compilationUnit ::= declaration*

declaration ::= includeDeclaration
               | contextMapDeclaration
               | contextDeclaration
               | aggregateDeclaration
               | entityDeclaration
               | valueObjectDeclaration
               | structDeclaration
               | implDeclaration
               | layeredDeclaration
               | sourceSetDeclaration
               | variableDeclaration
               | defDeclaration

includeDeclaration ::= INCLUDE_KEYWORD STRING_LITERAL ";"?  {
    pin = 1
    name = ""
    stubClass = "com.feakin.intellij.stubs.FkIncludeStub"
    mixin = "com.feakin.intellij.stubs.ext.FkIncludeMixin"
    elementTypeFactory = "com.feakin.intellij.stubs.StubImplementationsKt.factory"
}

contextMapDeclaration ::= CONTEXT_MAP_KEYWORD IDENTIFIER contextMapBody
{
  implements = [
    "com.feakin.intellij.psi.FkNamedElement"
    "com.feakin.intellij.psi.FkNameIdentifierOwner"
  ]
  mixin = "com.feakin.intellij.stubs.ext.FkContextMapImplMixin"
  stubClass = "com.feakin.intellij.stubs.FkContextMapDeclStub"
  elementTypeFactory = "com.feakin.intellij.stubs.StubImplementationsKt.factory"
}

contextMapBody ::= LBRACE (contextNodeDecl | contextNodeRel)* RBRACE

private contextNodeDecl ::= CONTEXT_KEYWORD contextName (COMMA contextName)*

private contextNodeRel ::= leftContextNode relSymbol rightContextNode SEMICOLON

private leftContextNode ::= contextName;

private rightContextNode ::= contextName;

relSymbol ::= RARROW
             | LARROW
             | DARROW
             | CONNECTION
             ;

contextDeclaration ::= CONTEXT_KEYWORD IDENTIFIER contextBody
{
  implements = [ "com.feakin.intellij.psi.FkNamedElement"
    "com.feakin.intellij.psi.FkNameIdentifierOwner"
    "com.feakin.intellij.psi.ext.FkMandatoryReferenceElement" ]
  mixin = "com.feakin.intellij.stubs.ext.FkContextDeclarationImplMixin"
  stubClass = "com.feakin.intellij.stubs.FkContextDeclStub"
  elementTypeFactory = "com.feakin.intellij.stubs.StubImplementationsKt.factory"
}

contextBody ::= LBRACE useAggregate* RBRACE

aggregateDeclaration ::= AGGREGATE_KEYWORD IDENTIFIER aggregateBody {
}

entityDeclaration ::= ENTITY_KEYWORD IDENTIFIER entityBody {
}

valueObjectDeclaration ::= VALUE_OBJECT_KEYWORD IDENTIFIER valueObjectBody {
}

private useAggregate ::= AGGREGATE_KEYWORD IDENTIFIER (COMMA IDENTIFIER)* SEMICOLON

aggregateBody ::= LBRACE (aggregateEntry*)? RBRACE

private aggregateEntry ::= domainEvent | useEntity

private domainEvent ::= DOMAIN_EVENT_KEYWORD IDENTIFIER (COMMA IDENTIFIER)* SEMICOLON?

private useEntity ::= ENTITY_KEYWORD IDENTIFIER (COMMA IDENTIFIER)* SEMICOLON

entityBody ::= LBRACE (structDeclaration | useValueObject | useStruct)* RBRACE

structDeclaration ::= STRUCT_KEYWORD structBody {
}

structBody ::= LBRACE structEntry* RBRACE

private structEntry ::= IDENTIFIER COLON fieldType defaultValue? SEMICOLON?

fieldType ::= IDENTIFIER ('<' IDENTIFIER '>')? ;

private defaultValue ::= EQUAL IDENTIFIER ('.' IDENTIFIER )?

private useValueObject ::= VALUE_OBJECT_KEYWORD IDENTIFIER (COMMA IDENTIFIER)* SEMICOLON?
private useStruct      ::= STRUCT_KEYWORD IDENTIFIER (COMMA IDENTIFIER)* SEMICOLON?

valueObjectBody ::= LBRACE (structDeclaration | useStruct)? RBRACE

implDeclaration ::= IMPL_KEYWORD IDENTIFIER implBody

implBody ::= LBRACE (set_target_object? endpointDeclaration flowDeclaration?)? RBRACE

endpointDeclaration ::= ENDPOINT_KEYWORD endpointBody

endpointBody ::= LBRACE requestDeclaration requestBody? authorizationDecl? responseDeclaration? RBRACE

private authorizationDecl ::= AUTH_KEYWORD COLON authorizationType (authorizationValue | STRING_LITERAL)* SEMICOLON?

authorizationValue ::= IDENTIFIER
authorizationType ::= IDENTIFIER

requestDeclaration ::= httpRequestDeclaration

private httpRequestDeclaration ::= httpMethod uri SEMICOLON?

httpMethod ::= GET_KEYWORD
              | POST_KEYWORD
              | PUT_KEYWORD
              | DELETE_KEYWORD
              | PATCH_KEYWORD
              | HEAD_KEYWORD
              | OPTIONS_KEYWORD
              ;

uri ::= STRING_LITERAL

requestBody ::= REQUEST_KEYWORD COLON (requestEntityName | structDeclaration) SEMICOLON?;

responseDeclaration ::= RESPONSE_KEYWORD COLON responseEntityName SEMICOLON?;

flowDeclaration ::= FLOW_KEYWORD flowBody

flowBody ::= LBRACE stepDeclaration* RBRACE

private stepDeclaration ::= VIA_KEYWORD objectName ((DOUBLE_COLON | DOT) viaMethodName parameters?)? (viaMethodDeclaration | viaMessageDeclaration)
                        | whenExpression

viaMethodDeclaration ::= RECEIVE_KEYWORD receiveObject SEMICOLON?

viaMessageDeclaration ::= SEND_KEYWORD passObject TO_KEYWORD topic SEMICOLON?

private passObject ::= objectName

parameters ::= LPAREN (parameter (COMMA parameter)*)? RPAREN

parameter ::= IDENTIFIER COLON paramType

paramType ::= IDENTIFIER ('<' IDENTIFIER '>')?;

private receiveObject ::= objectName (COLON viaMethodName)?

layeredDeclaration ::= LAYERED_KEYWORD IDENTIFIER layeredBody

layeredBody ::= LBRACE  dependency? layerDeclaration* RBRACE

set_target_object ::= AGGREGATE_S_KEYWORD COLON setAggregateName SEMICOLON?
                    | ENTITY_S_KEYWORD COLON setEntityName SEMICOLON?

setAggregateName ::= IDENTIFIER
setEntityName ::= IDENTIFIER

dependency ::= DEPENDENCY_KEYWORD LBRACE dependencyBody RBRACE

dependencyBody ::= dependency_rule*
dependency_rule ::= dep_source RARROW dep_target SEMICOLON?

dep_source ::= STRING_LITERAL
dep_target ::= STRING_LITERAL

layerDeclaration ::= LAYER_KEYWORD IDENTIFIER layerBody

layerBody ::= LBRACE (packageName)* RBRACE

packageName ::= PACKAGE_KEYWORD COLON STRING_LITERAL SEMICOLON?

topic ::= STRING_LITERAL

objectName ::= IDENTIFIER

viaMethodName ::= IDENTIFIER

requestEntityName ::= IDENTIFIER

responseEntityName ::= IDENTIFIER

sourceSetDeclaration ::= SOURCE_SET_KEYWORD IDENTIFIER sourceSetDeclBody

sourceSetDeclBody ::= LBRACE (sourceSetItem)* RBRACE

sourceSetItem ::= sourceSetName sourceSetItemBody

sourceSetName ::= IDENTIFIER

sourceSetItemBody ::= LBRACE sourceSetEntry* RBRACE

sourceSetEntry ::= entryKey COLON entryValue SEMICOLON?

entryKey ::= IDENTIFIER

entryValue ::= value | '[' value* ']'

whenExpression ::= WHEN_KEYWORD whenBody

whenBody ::= LPAREN IDENTIFIER RPAREN LBRACE whenEntry* RBRACE

whenEntry ::= IS_KEYWORD whenCondition "=>" whenEntryBody?

whenCondition ::= IDENTIFIER

whenEntryBody ::= LBRACE stepDeclaration* RBRACE

variableDeclaration ::= VAR_KEYWORD IDENTIFIER COLON fieldType variableBody

variableBody ::= LBRACE variableEntry* RBRACE

variableEntry ::= variableKey COLON entryValue SEMICOLON?

variableKey ::= IDENTIFIER | PACKAGE_KEYWORD

value ::= STRING_LITERAL | IDENTIFIER | NUMBER_LITERAL

defDeclaration ::= DEF_KEYWORD defIdent defBody

defIdent ::=  CONTEXT_MAP_KEYWORD
             | CONTEXT_KEYWORD
             | AGGREGATE_KEYWORD
             | ENTITY_KEYWORD
             | VALUE_OBJECT_KEYWORD

defBody ::= LBRACE structEntry* RBRACE

contextName ::= IDENTIFIER
{
  implements = [ "com.feakin.intellij.psi.ext.FkMandatoryReferenceElement" ]
  mixin = "com.feakin.intellij.stubs.ext.FkContextNameImplMixin"
}

