{
  parserClass="com.feakin.intellij.parser.FkParser"
  parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

  implements="com.feakin.intellij.psi.FkElement"
  extends="com.feakin.intellij.psi.impl.FkElementImpl"

  psiClassPrefix="Fk"
  psiImplClassSuffix="Impl"
  psiPackage="com.feakin.intellij.psi"
  psiImplPackage="com.feakin.intellij.psi.impl"

  elementTypeHolderClass="com.feakin.intellij.lexer.FkElementTypes"
  elementTypeClass="com.feakin.intellij.psi.FkElementType"

  tokenTypeClass="com.feakin.intellij.lexer.FkTokenType"

  tokenTypeClass="com.feakin.intellij.lexer.FkTokenType"
  tokens = [
      COMMENT               = 'regexp://[^\r\n]*'
      BLOCK_COMMENT         = 'regexp:[/][*][^*]*[*]+([^/*][^*]*[*]+)*[/]'

      IDENTIFIER            = 'regexp:[_a-zA-Z][_a-zA-Z0-9]*'
      STRING_LITERAL        = "regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"

      COMMA                 = ','
      COLON                 = ":"
      DOUBLE_COLON          = "::"
      SEMICOLON             = ";"
      LBRACE                = "{"
      RBRACE                = "}"
      EQUAL                 = "="
      QUOTA                 = "'"
      LPAREN                = '('
      RPAREN                = ')'
      LT                    =  '<'
      GT                    =  '>'
      DOT                   =  '.'
      RARROW                = "->"
      LARROW                = "<-"
      DARROW                = "<->"
      CONNECTION            = "--"

      CONTEXT_MAP_KEYWORD   = 'ContextMap'
      CONTEXT_KEYWORD       = 'Context'
      AGGREGATE_KEYWORD     = 'Aggregate'
      ENTITY_KEYWORD        = 'Entity'
      VALUE_OBJECT_KEYWORD  = 'ValueObject'
      STRUCT_KEYWORD        = 'Struct'
      IMPL_KEYWORD          = 'impl'
      ENDPOINT_KEYWORD      = 'endpoint'
      REQUEST_KEYWORD       = 'request'
      RESPONSE_KEYWORD      = 'response'

      GET_KEYWORD           = 'GET'
      POST_KEYWORD          = 'POST'
      PUT_KEYWORD           = 'PUT'
      DELETE_KEYWORD        = 'DELETE'
      PATCH_KEYWORD         = 'PATCH'
      HEAD_KEYWORD          = 'HEAD'
      OPTIONS_KEYWORD       = 'OPTIONS'
      AUTH_KEYWORD          = 'authorization'

      FLOW_KEYWORD          = 'flow'
      VIA_KEYWORD           = 'via'
      RECEIVE_KEYWORD       = 'receive'
      SEND_KEYWORD          = 'send'
      TO_KEYWORD            = 'to'
      FROM_KEYWORD          = 'from'
      LAYERED_KEYWORD       = 'layered'
      LAYER_KEYWORD         = 'layer'
      DEPENDENCY_KEYWORD    = 'dependency'
      PACKAGE_KEYWORD       = 'package'
  ]
}

compilationUnit ::= declaration*

declaration ::= contextMapDeclaration
               | contextDeclaration
               | aggregateDeclaration
               | entityDeclaration
               | valueObjectDeclaration
               | structDeclaration
               | implDeclaration
               | layeredDeclaration

contextMapDeclaration ::= CONTEXT_MAP_KEYWORD IDENTIFIER contextMapBody
{
  implements = [
    "com.feakin.intellij.psi.FkNamedElement"
    "com.feakin.intellij.psi.FkNameIdentifierOwner"
  ]
  mixin = "com.feakin.intellij.stubs.ext.FkContextMapImplMixin"
  stubClass = "com.feakin.intellij.stubs.FkContextMapDeclStub"
  elementTypeFactory = "com.feakin.intellij.stubs.StubImplementationsKt.factory"
}

contextMapBody ::= LBRACE (contextNodeDecl | contextNodeRel)* RBRACE

private contextNodeDecl ::= CONTEXT_KEYWORD contextName (COMMA contextName)*

private contextNodeRel ::= leftContextNode relSymbol rightContextNode SEMICOLON

private leftContextNode ::= contextName;

private rightContextNode ::= contextName;

relSymbol ::= RARROW
             | LARROW
             | DARROW
             | CONNECTION
             ;

contextDeclaration ::= CONTEXT_KEYWORD IDENTIFIER contextBody
{
  implements = [ "com.feakin.intellij.psi.FkNamedElement"
    "com.feakin.intellij.psi.FkNameIdentifierOwner"
    "com.feakin.intellij.psi.ext.FkMandatoryReferenceElement" ]
  mixin = "com.feakin.intellij.stubs.ext.FkContextDeclarationImplMixin"
  stubClass = "com.feakin.intellij.stubs.FkContextDeclStub"
  elementTypeFactory = "com.feakin.intellij.stubs.StubImplementationsKt.factory"
}

contextBody ::= LBRACE useAggregate* RBRACE

aggregateDeclaration ::= AGGREGATE_KEYWORD IDENTIFIER aggregateBody {
}

entityDeclaration ::= ENTITY_KEYWORD IDENTIFIER entityBody {
}

valueObjectDeclaration ::= VALUE_OBJECT_KEYWORD IDENTIFIER valueObjectBody {
}

private useAggregate ::= AGGREGATE_KEYWORD IDENTIFIER (COMMA IDENTIFIER)* SEMICOLON

aggregateBody ::= LBRACE aggregateEntry* RBRACE

private aggregateEntry ::= useEntity

private useEntity ::= ENTITY_KEYWORD IDENTIFIER (COMMA IDENTIFIER)* SEMICOLON

entityBody ::= LBRACE (structDeclaration | useValueObject | useStruct)? RBRACE

structDeclaration ::= STRUCT_KEYWORD structBody {
}

structBody ::= LBRACE structEntry* RBRACE

private structEntry ::= IDENTIFIER COLON fieldType defaultValue? SEMICOLON?

fieldType ::= IDENTIFIER ('<' IDENTIFIER '>')? ;

private defaultValue ::= EQUAL IDENTIFIER ('.' IDENTIFIER )?

private useValueObject ::= VALUE_OBJECT_KEYWORD IDENTIFIER (COMMA IDENTIFIER)? SEMICOLON
private useStruct      ::= STRUCT_KEYWORD IDENTIFIER (COMMA IDENTIFIER)? SEMICOLON

valueObjectBody ::= LBRACE (structDeclaration | useStruct)? RBRACE

implDeclaration ::= IMPL_KEYWORD IDENTIFIER implBody {}

implBody ::= LBRACE (endpointDeclaration flowDeclaration?)? RBRACE

endpointDeclaration ::= ENDPOINT_KEYWORD endpointBody

endpointBody ::= LBRACE requestDeclaration requestBody? authorizationDecl? responseDeclaration? RBRACE

private authorizationDecl ::= AUTH_KEYWORD COLON authorizationType? authorizationValue* SEMICOLON?

authorizationValue ::= IDENTIFIER
authorizationType ::= IDENTIFIER

requestDeclaration ::= httpRequestDeclaration

private httpRequestDeclaration ::= httpMethod uri SEMICOLON

httpMethod ::= GET_KEYWORD
              | POST_KEYWORD
              | PUT_KEYWORD
              | DELETE_KEYWORD
              | PATCH_KEYWORD
              | HEAD_KEYWORD
              | OPTIONS_KEYWORD
              ;

uri ::= STRING_LITERAL

requestBody ::= REQUEST_KEYWORD COLON (requestEntityName | structDeclaration) SEMICOLON;

responseDeclaration ::= RESPONSE_KEYWORD COLON responseEntityName SEMICOLON;

flowDeclaration ::= FLOW_KEYWORD flowBody

flowBody ::= LBRACE stepDeclaration* RBRACE

private stepDeclaration ::= viaMethodDeclaration
                     | viaMessageDeclaration

viaMethodDeclaration ::= VIA_KEYWORD objectName ((DOUBLE_COLON | DOT) viaMethodName parameters?)? RECEIVE_KEYWORD receiveObject SEMICOLON?

parameters ::= LPAREN parameter (COMMA parameter)* RPAREN

parameter ::= IDENTIFIER COLON paramType

paramType ::= IDENTIFIER ('<' IDENTIFIER '>')?;

private receiveObject ::= objectName (COLON viaMethodName)?

viaMessageDeclaration ::= VIA_KEYWORD objectName SEND_KEYWORD passObject TO_KEYWORD topic SEMICOLON?

private passObject ::= objectName (COLON viaMethodName)?

layeredDeclaration ::= LAYERED_KEYWORD IDENTIFIER layeredBody

layeredBody ::= LBRACE dependency? layerDeclaration* RBRACE

dependency ::= DEPENDENCY_KEYWORD LBRACE dependency_rule* RBRACE

dependency_rule ::= dep_source RARROW dep_target SEMICOLON?

dep_source ::= STRING_LITERAL
dep_target ::= STRING_LITERAL

layerDeclaration ::= LAYER_KEYWORD IDENTIFIER layerBody

layerBody ::= LBRACE (packageName)* RBRACE

packageName ::= PACKAGE_KEYWORD COLON STRING_LITERAL SEMICOLON?

topic ::= STRING_LITERAL

objectName ::= IDENTIFIER

viaMethodName ::= IDENTIFIER

requestEntityName ::= IDENTIFIER

responseEntityName ::= IDENTIFIER

contextName ::= IDENTIFIER
{
  implements = [ "com.feakin.intellij.psi.ext.FkMandatoryReferenceElement" ]
  mixin = "com.feakin.intellij.stubs.ext.FkContextNameImplMixin"
}

